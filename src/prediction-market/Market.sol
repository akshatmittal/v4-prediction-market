pragma solidity ^0.8.20;

import "./MarketMaker.sol";
import "./Event.sol";
import "./Market.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "forge-std/console.sol";

contract MarketData {
    event MarketFunding(uint256 funding);
    event MarketClosing();
    event FeeWithdrawal(uint256 fees);
    event OutcomeTokenPurchase(
        address indexed buyer,
        uint8 outcomeTokenIndex,
        uint256 outcomeTokenCount,
        uint256 outcomeTokenCost,
        uint256 marketFees
    );
    event OutcomeTokenSale(
        address indexed seller,
        uint8 outcomeTokenIndex,
        uint256 outcomeTokenCount,
        uint256 outcomeTokenProfit,
        uint256 marketFees
    );
    event OutcomeTokenShortSale(
        address indexed buyer, uint8 outcomeTokenIndex, uint256 outcomeTokenCount, uint256 cost
    );
    event OutcomeTokenTrade(
        address indexed transactor, int256[] outcomeTokenAmounts, int256 outcomeTokenNetCost, uint256 marketFees
    );

    address public creator;
    uint256 public createdAtBlock;
    Event public eventContract;
    MarketMaker public marketMaker;
    uint24 public fee;
    uint256 public funding;
    int256[] public netOutcomeTokensSold;

    enum Stages {
        MarketCreated,
        MarketFunded,
        MarketClosed
    }

    Stages public stage;
}

/// @title Standard market contract - Backed implementation of standard markets
contract Market is MarketData {
    uint24 public constant FEE_RANGE = 100_0000; // 100%

    /*
     *  Modifiers
     */
    modifier isCreator() {
        // Only creator is allowed to proceed
        require(msg.sender == creator);
        _;
    }

    modifier atStage(Stages _stage) {
        // Contract has to be in given stage
        require(stage == _stage);
        _;
    }

    constructor(address _creator, Event _eventContract, MarketMaker _marketMaker, uint24 _fee) {
        // Validate inputs
        require(address(_eventContract) != address(0) && address(_marketMaker) != address(0) && _fee < FEE_RANGE);
        creator = _creator;
        createdAtBlock = block.number;
        eventContract = _eventContract;
        netOutcomeTokensSold = new int256[](eventContract.getOutcomeCount());
        fee = _fee;
        marketMaker = _marketMaker;
        stage = Stages.MarketCreated;
    }

    /*
     *  Public functions
     */
    /// @dev Allows to fund the market with collateral tokens converting them into outcome tokens
    /// @param _funding Funding amount
    function fund(uint256 _funding) public isCreator atStage(Stages.MarketCreated) {
        require(
            eventContract.collateralToken().transferFrom(msg.sender, address(this), _funding)
                && eventContract.collateralToken().approve(address(eventContract), _funding)
        );
        eventContract.buyAllOutcomes(_funding);
        funding = _funding;
        stage = Stages.MarketFunded;
        emit MarketFunding(funding);
    }

    /// @dev Allows market creator to close the markets by transferring all remaining outcome tokens to the creator
    function close() public isCreator atStage(Stages.MarketFunded) {
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i = 0; i < outcomeCount; i++) {
            require(
                eventContract.outcomeTokens(i).transfer(
                    creator, eventContract.outcomeTokens(i).balanceOf(address(this))
                )
            );
        }
        stage = Stages.MarketClosed;
        emit MarketClosing();
    }

    /// @dev Allows market creator to withdraw fees generated by trades
    /// @return fees amount
    function withdrawFees() public isCreator returns (uint256 fees) {
        fees = eventContract.collateralToken().balanceOf(address(this));
        // Transfer fees
        require(eventContract.collateralToken().transfer(creator, fees));
        emit FeeWithdrawal(fees);
    }

    /// @dev Allows to buy outcome tokens from market maker
    /// @param outcomeTokenIndex Index of the outcome token to buy
    /// @param outcomeTokenCount Amount of outcome tokens to buy
    /// @param maxCost The maximum cost in collateral tokens to pay for outcome tokens
    /// @return cost in collateral tokens
    function buy(uint8 outcomeTokenIndex, uint256 outcomeTokenCount, uint256 maxCost)
        public
        atStage(Stages.MarketFunded)
        returns (uint256 cost)
    {
        require(int256(outcomeTokenCount) >= 0 && int256(maxCost) > 0);
        uint8 outcomeCount = eventContract.getOutcomeCount();
        require(outcomeTokenIndex >= 0 && outcomeTokenIndex < outcomeCount);
        int256[] memory outcomeTokenAmounts = new int256[](outcomeCount);
        outcomeTokenAmounts[outcomeTokenIndex] = int256(outcomeTokenCount);
        (int256 netCost, int256 outcomeTokenNetCost, uint256 fees) =
            tradeImpl(outcomeCount, outcomeTokenAmounts, int256(maxCost));
        require(netCost >= 0 && outcomeTokenNetCost >= 0);
        cost = uint256(netCost);
        emit OutcomeTokenPurchase(msg.sender, outcomeTokenIndex, outcomeTokenCount, uint256(outcomeTokenNetCost), fees);
    }

    /// @dev Allows to sell outcome tokens to market maker
    /// @param outcomeTokenIndex Index of the outcome token to sell
    /// @param outcomeTokenCount Amount of outcome tokens to sell
    /// @param minProfit The minimum profit in collateral tokens to earn for outcome tokens
    /// @return profit in collateral tokens
    function sell(uint8 outcomeTokenIndex, uint256 outcomeTokenCount, uint256 minProfit)
        public
        atStage(Stages.MarketFunded)
        returns (uint256 profit)
    {
        require(-int256(outcomeTokenCount) <= 0 && -int256(minProfit) < 0);
        uint8 outcomeCount = eventContract.getOutcomeCount();
        require(outcomeTokenIndex >= 0 && outcomeTokenIndex < outcomeCount);
        int256[] memory outcomeTokenAmounts = new int256[](outcomeCount);
        outcomeTokenAmounts[outcomeTokenIndex] = -int256(outcomeTokenCount);
        (int256 netCost, int256 outcomeTokenNetCost, uint256 fees) =
            tradeImpl(outcomeCount, outcomeTokenAmounts, -int256(minProfit));
        require(netCost <= 0 && outcomeTokenNetCost <= 0);
        profit = uint256(-netCost);
        emit OutcomeTokenSale(msg.sender, outcomeTokenIndex, outcomeTokenCount, uint256(-outcomeTokenNetCost), fees);
    }

    /// @dev Buys all outcomes, then sells all shares of selected outcome which were bought, keeping
    /// @param outcomeTokenIndex Index of the outcome token to short sell
    /// @param outcomeTokenCount Amount of outcome tokens to short sell
    /// @param minProfit The minimum profit in collateral tokens to earn for short sold outcome tokens
    /// @return cost Cost to short sell outcome in collateral tokens
    ///      shares of all other outcome tokens.
    function shortSell(uint8 outcomeTokenIndex, uint256 outcomeTokenCount, uint256 minProfit)
        public
        returns (uint256 cost)
    {
        // Buy all outcomes
        require(
            eventContract.collateralToken().transferFrom(msg.sender, address(this), outcomeTokenCount)
                && eventContract.collateralToken().approve(address(eventContract), outcomeTokenCount)
        );
        eventContract.buyAllOutcomes(outcomeTokenCount);
        // Short sell selected outcome
        eventContract.outcomeTokens(outcomeTokenIndex).approve(address(this), outcomeTokenCount);
        uint256 profit = this.sell(outcomeTokenIndex, outcomeTokenCount, minProfit);
        cost = outcomeTokenCount - profit;
        // Transfer outcome tokens to buyer
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i = 0; i < outcomeCount; i++) {
            if (i != outcomeTokenIndex) {
                require(eventContract.outcomeTokens(i).transfer(msg.sender, outcomeTokenCount));
            }
        }
        // Send change back to buyer
        require(eventContract.collateralToken().transfer(msg.sender, profit));
        emit OutcomeTokenShortSale(msg.sender, outcomeTokenIndex, outcomeTokenCount, cost);
    }

    /// @dev Allows to trade outcome tokens and collateral with the market maker
    /// @param outcomeTokenAmounts Amounts of each outcome token to buy or sell. If positive, will buy this amount of outcome token from the market. If negative, will sell this amount back to the market instead.
    /// @param collateralLimit If positive, this is the limit for the amount of collateral tokens which will be sent to the market to conduct the trade. If negative, this is the minimum amount of collateral tokens which will be received from the market for the trade. If zero, there is no limit.
    /// @return netCost If positive, the amount of collateral sent to the market. If negative, the amount of collateral received from the market. If zero, no collateral was sent or received.
    function trade(int256[] memory outcomeTokenAmounts, int256 collateralLimit)
        public
        atStage(Stages.MarketFunded)
        returns (int256 netCost)
    {
        uint8 outcomeCount = eventContract.getOutcomeCount();
        require(outcomeTokenAmounts.length == outcomeCount);

        int256 outcomeTokenNetCost;
        uint256 fees;
        (netCost, outcomeTokenNetCost, fees) = tradeImpl(outcomeCount, outcomeTokenAmounts, collateralLimit);

        emit OutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, fees);
    }

    function tradeImpl(uint8 outcomeCount, int256[] memory outcomeTokenAmounts, int256 collateralLimit)
        private
        returns (int256 netCost, int256 outcomeTokenNetCost, uint256 fees)
    {
        // Calculate net cost for executing trade
        outcomeTokenNetCost = marketMaker.calcNetCost(this, outcomeTokenAmounts);
        if (outcomeTokenNetCost < 0) {
            fees = calcMarketFee(uint256(-outcomeTokenNetCost));
        } else {
            fees = calcMarketFee(uint256(outcomeTokenNetCost));
        }

        require(int256(fees) >= 0);
        netCost = outcomeTokenNetCost + (int256(fees));

        require((collateralLimit != 0 && netCost <= collateralLimit) || collateralLimit == 0);

        uint256 allowance = eventContract.collateralToken().allowance(msg.sender, address(this));

        if (outcomeTokenNetCost > 0) {
            require(
                eventContract.collateralToken().transferFrom(msg.sender, address(this), uint256(netCost))
                    && eventContract.collateralToken().approve(address(eventContract), uint256(outcomeTokenNetCost))
            );

            eventContract.buyAllOutcomes(uint256(outcomeTokenNetCost));
        }

        for (uint8 i = 0; i < outcomeCount; i++) {
            if (outcomeTokenAmounts[i] != 0) {
                if (outcomeTokenAmounts[i] < 0) {
                    require(
                        eventContract.outcomeTokens(i).transferFrom(
                            msg.sender, address(this), uint256(-outcomeTokenAmounts[i])
                        )
                    );
                } else {
                    require(eventContract.outcomeTokens(i).transfer(msg.sender, uint256(outcomeTokenAmounts[i])));
                }

                netOutcomeTokensSold[i] = netOutcomeTokensSold[i] + (outcomeTokenAmounts[i]);
            }
        }

        if (outcomeTokenNetCost < 0) {
            // This is safe since
            // 0x8000000000000000000000000000000000000000000000000000000000000000 ==
            // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))
            eventContract.sellAllOutcomes(uint256(-outcomeTokenNetCost));
            if (netCost < 0) {
                require(eventContract.collateralToken().transfer(msg.sender, uint256(-netCost)));
            }
        }
    }

    /// @dev Calculates fee to be paid to market maker
    /// @param outcomeTokenCost Cost for buying outcome tokens
    /// @return Fee for trade
    function calcMarketFee(uint256 outcomeTokenCost) public view returns (uint256) {
        return (outcomeTokenCost * fee) / FEE_RANGE;
    }
}
